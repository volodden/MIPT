Архитектура компьютеров и операционные системы (второй семестр)
===============================
Семинарист: Крохалев Евгений.
Условия задач
=============
01. Различные слова
-----------------------
#### Описание
Написать программу, вычисляющую число различных слов в файле. Словом считается любая последовательность символов, не содержащая пробелов, табов и переводов строки. Программа должна корректно работать на файлах произвольного содержимого (даже на бинарных файлах).
#### Пример
input file<br/>
```small text that would contain words those contain letters```<br/>
output<br/>
```8           ```<br/>
02. Библиотека, реализующая интерфейс хэш-таблицы
-----------------------------------
#### Описание
Реализовать библиотеку, позволяющую работать с хэш-таблицами (http://en.wikipedia.org/wiki/Hash_table).<br/>
Необходимые операции: добавление записи по строковому ключу, поиск записи по ключу, удаление записи по ключу.<br/>
Результат должен представлять собой динамически подгружаемую библиотеку (.so).<br/>
Дополнительно следует предоставить программу, демонстрирующую применение вашей библиотеки на практике.
03. Аналог утилиты ls
---------------------
#### Описание
Реализовать аналог программы ls, эквивалентный работе ls -lR.<br/>
При переданных параметрах командной строки утилита должна вывести актуальную информацию о соответствующих файлах и директориях.<br/>
Если параметров нет - вывести актуальную информацию о текущем рабочем каталоге.<br/>
http://pubs.opengroup.org/onlinepubs/009695399/utilities/ls.html
#### Пример
input<br/>
```./ls a.txt```<br/>
output<br/>
```-rw-r--r-- 1 nobody nogroup 2793 2009-10-29 17:43 a.txt```
#### Требования: программа должна работать на любых данных.
04. Вычисление чисел Фибоначчи на ассемблере
---------------------------------------------
#### Описание
Написать программу на ассемблере, вычисляющую числа Фибоначчи.<br/>
Вычисления нужно реализовать 2 способами - рекуррентно (т.е. циклом) и рекурсивно.<br/>
Номер вычисляемого числа Фибоначчи достаточно, чтобы задавался константой внутри программы.<br/>
Оба вычисленных результата (вернее один и тот же результат, вычисленный 2 способами) нужно вывести на экран.
05. Конвеер команд
-------------------------
#### Описание
Реализовать программу запускающую N переданных ей команд конвеером (output i-ой команды подаётся на вход i+1-ой команде)<br/>
То есть при запуске<br/>
```./yourprogram "cmd1 prm1" "cmd2 prm2" "cmd3" "cmd4 prm4"```<br/>
программа должна запустить 4 программы (cmd1, cmd2, cmd3, cmd4) с соответствующими параметрами, а
* 1-ая программа должна получить stdin от ./yourprogram
* stdout 1-ой программы перенаправить в stdin 2-ой программы,
* stdout 2-ой программы - в stdin 3-ей,
* stdout 3-ей - в stdin 4-ой
* stdout 4-ой должен быть выведен в консоль
06. Параллельное вычисление функции
----------------------------------------
### Описание
Реализовать параллельное вычисление логарифма и арктангенса (через суммирование N первых членов соответствующих рядов тейлора).<br/>
В случае логарифма действия выполнять с комплексными числами.<br/>
Вычисления стоит распараллелить по схеме 1 мастер и 2 слейва.<br/>
Элементы ряда нужно вычислять в слейв процессах, а складывать их в мастер-процессе.<br/>
Общение между мастер и слейв процессами стоит реализовать 2 способами:<br/>
Данные передавать через пайпы, синхронизировать передачу данных при помощи сигналов (pipe, signal, sigaction, ...).<br/>
Данные передавать посредством очереди сообщений (mq_open, mq_close, mq_send, mq_receive)<br/>
В качестве доказательства корректности расчётов - показать на нескольких точках верность равенства<br/>
```arctg z = i/2(ln(1 - iz) - ln(1 + iz))```
07. Эмуляция проблемы про обедающих философов
--------------------------------------
### Background
K философов сидят за круглым столом, в центре которого стоит блюдо с рисом. Между каждой парой философов лежит палочка для еды, палочек, следовательно, тоже K. Для того, чтобы начать есть, философ должен взять две палочки - слева и справа от себя. Таким образом, если один из философов ест, его соседи справа и слева лишены такой возможности, так как им недостает палочек. Каждый философ "работает" по зацикленному алгоритму: сначала он некоторое время думает, затем берет палочки и ест, затем опять думает и т.д. Временные интервалы мышления и еды случайны, действия философов, следовательно, не синхронизированы.

### Условие
Проэммулировать указанную ситуацию. Философы - отдельные процессы, палочки - семафоры (или мютексы).<br/>
В условии ничего не говорится про то каким образом философы берут палочки.<br/>
Необходимо реализовать 2 варианта эмуляции:
* "наивный" алгоритм, при котором не гарантируется возникновение deadlock'ов или бесконечного голодания одного из философов;
* алгоритм, при котором гарантируется, что никогда не возникнет deadlock'а или бесконечного голодания.
