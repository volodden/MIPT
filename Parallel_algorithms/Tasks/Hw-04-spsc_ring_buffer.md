## Single-Producer/Single Consumer (SP/SC) Wait-Free Ring Buffer [spsc_ring_buffer]

Реализуйте закольцованную очередь на основе буфера фиксированной длины ```spsc_ring_buffer<T>```, которая поддерживала бы две операции:

1) ```bool enqueue(T e)``` - записать элемент ```e``` в хвост очереди и вернуть ```true```, если в буфере есть место для элемента, в противном случае (переполнение) вернуть ```false```

2) ```bool dequeue(T& e)``` - если очередь не пуста, то извлечь элемент из головы очереди и вернуть ```true```, в противном случае вернуть ```false```

Закольцованность означает, что за записью последнего элемента буфера следует запись в первый элемент, т.е. очередь ползает в буфере по кругу.



---

Циклическая очередь должна быть рассчитана только на single-producer/single-consumer режим использования, когда есть единственный-producer поток, который только пишет элементы в очередь, и единственный поток-consumer, который только читает данные из очереди.

Реализация должна быть wait-free: каждая из двух операций должна завершаться за КОНЕЧНОЕ ЧИСЛО ШАГОВ вне зависимости от того, что в данный момент делает другая операция в другом потоке.

wait-freedom - это самая сильная гарантия для конкурентных структур данных, она означает запрет на использование мьютексов и спинлоков, даже честных (fair), т.к. если один из потоков захватит мьютекс или спинлок и будет приостановлен планировщиком, то другой поток не сможет продвигаться дальше. Если же мьютекс или спинлок нечестный, то поток вообще может ожидать сколь угодно долго.

Для синхронизации потоков должны использоваться только атомарные переменные и две модели упорядочивания чтений/записей: relaxed ordering и release/acquire semantics

relaxed ordering гарантирует, что если потоком прочитано значение Y, то тот же поток не может прочитать более старое значение X + гарантирует, что поток всегда видит свои собственные записи

release/acquire-семантика позволяет упорядочить записи и чтения одних и тех же данных между двумя потоками

Обязательно обоснуйте свой выбор memory ordering-а для каждой атомарной операции чтения/записи.

Если не знаете, с чего начать - напишите однопоточную реализацию методов enqueue/dequeue и подумайте, какие проблемы могут возникнуть в случае работы двух потоков.

Подсказка: если переменную может изменить, к примеру, только один поток-producer, то не имеет смысла в методе enqueue использовать атомарное чтение и memory ordering каждый раз, достаточно прочитать значение один раз с нужным memory ordering-ом в локальную переменную.

Подсказка: из атомарных операций не понадобится ничего сложнее store и load.

---

Емкость буфера (capacity) должна задаваться с помощью конструктора: ```spsc_ring_buffer<T> ring_buffer(1024)```;

Хранить элементы буфера можно с помощью ```std::vector<T>```

При добавлении/извлечении элементов очередь будет ползать по кругу закольцованного буфера, для работы с ней поддерживайте два индекса:

1) ```head``` - индекс головы очереди - указывает на элемент, который будет извлечен при следующем вызове ```dequeue```

2) ```tail``` - индекс свободного слота за последним элементом в очереди, куда будет записан очередной элемент при следующем вызове enqueue

Тонкий вопрос: как отличить пустую очередь от полной?
Если в ```dequeue``` из очереди извлекается последний элемент, то ```head``` сдвигается вперед и становится равным tail. Когда очередь в enqueue заполняется целиком, то tail сдвигается вперед и тоже начинает совпадать с ```head```. Получаем ```head == tail``` в двух противоположных состояниях, хотя операции должны различать эти состояния.

Для решения этой проблемы можно потребовать, чтобы между хвостом и головой очереди в буфере оставался по крайней мере один свободный слот, тогда проверка на пустоту не меняется (head = tail), а проверка на переполнение становится другой: ```next(tail) = head```, где ```net``` - индекс следующего слота с учетом закольцованности.



Для решения этой же проблемы можно было бы воспользоваться атомарным счетчиком числа элементов, но это было бы менее эффективно: он требовал бы тяжелых операций атомарного инкремента/декремента даже в тех случаях, когда голова и хвост далеко друг от друга и поток-консьюмер никак не пересекается в своей работе с потоком-продьюсером. Кроме того, такое решение не выгодно и с точки зрения синхронизации кэшей.
