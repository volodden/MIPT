## lock-free queue [lock-free-queue]

Напишите ```lock-free queue``` + стратегию с точками затишься (```quiescent points```) для решения проблемы утилизации памяти (```safe memory reclamation```)

Оригинальная статья:  

Maged Michael, Michael Scott - Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms

---

Разумеется, контейнер должен быть шаблонным.

---

Бонусная часть - реализация более продвинутого механизма утилизации памяти:

A) ```node recycling: free-pool + tagged pointers```

После извлечения узла из контейнера (очереди или стека) он помещается в специальный пул свободных узлов (```free-pool```). Поток, который добавляет элемент в контейнер, сначала пытается взять узел из пула, и только в случае, если они закончились, аллоцирует новый узел.

```free-pool``` будет обычным ```lock-free``` стеком и будет устроен точно так же, как и основной стек/очередь: узлы будут провязаны в односвязный список с помощью тех же указателей. 

Получается, что внутри ```lock-free-stack/queue``` будет другой ```lock-free stack``` и основной контейнер постоянно будет обмениваться с ним узлами.


Перед тем, как приступить к реализации, найдите в таком подходе ABA-проблему в методе ```pop/dequeue```.

Чтобы избавиться от ABA-проблемы, используйте ```tagged pointers``` - пару из указателя и номера версии этого указателя, которая бы допускала ```lock-free CAS```. Номер версии будет обновляться при каждой перезаписи, тем самым исключая (или значительно снижая вероятность) ABA.

B) ```hazard pointers``` (указатели опасности)