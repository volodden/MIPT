## Очередь задач / пул потоков [thread-pool]


Очередь задач (task queue) или пул потоков (thread pool) - это распространенный паттерн многопоточного программирования для запуска асинхронных задач. Под асинхронной задачей здесь понимается любая функция, замыкание или функтор, которые выполняются в отдельном потоке, не блокируя на время выполнения клиентский поток, который ставит эту задачу. 


---

Как выглядит работа с очередью задач?


Для начала передаем задачу на выполнение в пул потоков:

```
async_task_result async_result = task_queue.submit(async_task);
```

Дальше очередь сама запускает async_task в отдельном потоке. При этом выполнение текущего потока не блокируется на время выполнения задачи, он может продолжать работу, делая свои очень важные дела.


Когда потоку понадобится результат асинхронного вычисления, то он может попросить у своего асинхронного результата вернуть ему вычисленное значение:

```
auto result_value = async_result.get();
```

Вызов этого метода - точка синхронизации потока-заказчика и асинхронного вычисления. Если асинхронная задача уже завершилась к этому времени, то вызов get() сразу вернет результат. Если же задача еще выполняется, то метод get() блокирует выполнение потока-заказчика до окончания выполнения задачи.


---

Когда такое может быть нужно? 


Например, приложение может выполнять асинхронные чтения с диска или записи на диск, чтобы не блокироваться на время их выполнения.


Другой пример: веб-браузер при загрузке веб-страницы получает html, в котором могут быть ссылки на изображения, которые снова нужно скачивать. В такой ситуации бразуер может не ждать, пока все изображения будут загружены, а поставить в пул потоков задачи по закачке этих изображений, а сам в это время отрисовать страницу без них.


Другой пример: веб-краулер поисковой системы, который обходит страницы Интернета. Задача, помещаемая в пул, в этом случае может выглядеть так: скачать страницу из сети, распарсить ее и извлечь все исходящие ссылки, после чего добавить в очередь задачь новые ссылки. Т.е. задачи сами добавляют в очередь новые задачи.


---


Что представляет из себя пул потоков изнутри? Это фиксированное число специальных потоков-воркеров (worker threads), исполняющих пользовательские задачи. Потоки-воркеры не создаются и уничтожаются на каждую задачу, а используются повторно: воркер, завершивший выполнение одной задачи, тут же принимается за следующую, если она есть. Задачи поступают воркерам через потокобезопасную (thread-safe) очередь, что обеспечивает приоритет их выполнения: чем раньше задача была отправлена в пул, тем раньше она начнет выполняться. Общая очередь также обеспечивает распределение нагрузки между воркерами (load balancing): если в пуле есть свободный поток-воркер, то он пытается взять из очереди очередную задачу и выполнить ее, так что при наличии достаточного числа задач воркеры никогда не простаивают.


Разумно ограничить размер очереди задач, чтобы не дать потокам-заказчикам заводить бесконечно заводить задачи, которые пул не успевает выполнять, это может привести к неограниченном потреблению памяти. В таких случаях очередь внутри пула делают ограниченной (bounded) и делают два метода добавления задач:


* блокирующий submit, который блокирует поток, добавляющий задачу, если очередь переполнена
* неблокирующий try_submit, который возвращает false, если задачу добавить не удается


---


Зачем вообще нужен пул из фиксированного числа потоков, если для каждой асинхронной задачи можно просто запустить отдельный поток и выполнить задачу там (тем более, такой механизм в стандартной библиотеке уже есть и называется std::async)? Причин две: 


Во-первых, запуск потока - это системный вызов и последующая работа внутри ядра операционной системы (нужно завести новый объект-поток  в ядре, завести для него стек, передать планировщику на выполнение), т.е. довольно тяжелая операция, временные расходы на которую могут превышать время выполнения самой асинхронной задачи! В таком случае никакого выигрыша от асинхронного исполнения не будет. Пул потоков, напротив, не запускает потоки на каждую задачу, а создает их в начале работы и потом переиспользует.


Во-вторых, если запускать новую задачу каждый раз в отдельном потоке, то, вероятно, число одновременно запущенных потоков скоро станет большим и привысит число аппаратных ресурсов (ядер процессора). Такая ситуация называется oversubscription и плоха она тем, что планировщик операционной системы, стараясь быть честным (fair), будет постоянно прерывать одни потоки и переключать их на другие (preemption), т.к. на всех не хватает ядер, а каждое такое переключение (оно называется context switch) - это существеная трата времени (переключение в режим ядра, работа планировщика, сохранение/восстановление содержимого регистров), в результате та же самая работа по выполнению задач происходит медленнее, чем при меньшем числе потоков.


Итак, плюсы использования пула задач: переиспользование потоков и ограничение числа одновременно бегущих задач.


---


Вопросы на понимание:


1. Обязательно ли задача, которая была первой помещена в очередь задач, будет выполнена первой? 
2. Почему не следует запускать число потоков больше, чем число ядер процессора, т.е. чем вредная ситуация oversubscription?
3. Что произойдет, если в пул будут отправлять задачи, которые работают значительно дольше остальных?
4. Можно ли получить взаимную блокировку (deadlock) при работе с пулом, в котором задачи сами могут добавлять в пул новые задачи?


---


Рекомендации и подсказки:


1) Для передачи задач в пул потоков (они могут быть обычными функциями, замыканиями или обертками, которые вернул std::bind) вам пригодится std::function - универсальная обертка, которая может оборачивать произвольные callable-объекты.


http://en.cppreference.com/w/cpp/utility/functional/function
http://en.cppreference.com/w/cpp/utility/functional/function/operator%28%29


https://code.google.com/p/mipt-parallel-2015/source/browse/trunk/functions/functions.cpp


2) Как запускать в пуле функции, которые принимают на вход аргументы? 


На самом деле это не нужно, пулу достаточно принимать только функции без аргументов. Если поток-клиент хочет добавить в пул функцию f с аргументами x и y, то он просто заворачивает в один объект-враппер с помощью std::bind(f, x, y). В результате получается объект с оператором () без аргументов, который уже вызывает f(x, y). А дальше этот объект уже можно передавать в пул потоков:

```
task_queue.submit( std::bind(f, x, y) );
```

3) Пулу достаточно запускать задачи без аргументов, для остальных случаев есть std::bind. Так что единственная степень свободы - тип результата, который возвращает задача. Этим типом можно параметризовать очередь задач: task_queue<ResultType>


4) Для возврата асинхронного результата из потока-воркера в пуле клиентам нужно использовать механизм future/promise - простой асинхронный канал для публикации/чтения значения.


Скринкаст: http://www.youtube.com/watch?v=o0pCft99K74&index=4
http://bartoszmilewski.com/2009/03/03/broken-promises-c0x-futures/


Внутри пула задача будет представлять собой пару из std::function (сама функция, которую нужно запустить потоку-воркеру) и std::promise, с помощью которого воркер опубликует результат вызова этой функции (или сообщит, что было брошено исключение).


Поток-клиент при добавлении задачи получит std::future, с помощью которого сможет получить асинхронный результат, который опубликует поток-воркер.

```
task_queue<R> tasks(...);
std::future<R> async_result = tasks.submit( [](){ return 42; } );
R result_value = async_result.get();
```

---


Для начала сделайте [подводящую задачу](HW-01-Producer%20and%20Consumers.md).
