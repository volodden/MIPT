## Задача 2. Иерархический мьютекс [hierarchical-mutex]

Один из способов гарантированно предотвратить возникновение дэдлоков - не допускать появления циклов в ```wait-for``` или ```resource allocation``` графах, тем самым нарушается необходимое для возникновения дэдлока условие ```circular wait``` (см. условия Коффмана).

Добиться этого можно, используя иерархию блокировок (```lock hierarchy```).

```Lock hierarchy```:

Каждому из мьютексов приписывается натуральное число - уровень в иерархии. Захватывать мьютексы допускается только в порядке строгого убывания уровня, тогда мы получаем гарантию, что циклической зависимости между потоками не возникает.

Попытка захватить мьютексы в порядке, который нарушает иерархию - путь к дедлоку.

---

Что нужно сделать:

Напишите обертку над стандартным мьютексом со встроенным механизмом контроля за иерархией блокировок, назовем такой мьютекс иерархическим (```hierarchical mutex```).

Каждому иерархическому мьютексу L в конструкторе приписывается целое число ```L(M)``` - его уровень в иерархии блокировок. Предполагается, что программист уже спроектировал иерархию блокировок и знает, на каком уровне в ней располагается каждый мьютекс, который он заводит.

Поток может захватить иерархический мьютекс ```М``` уровня ```L(М)``` только если он не владеет ни одним мьютексом либо последний захваченный и удерживаемый им мьютекс ```М'``` в иерархии расположен выше: уровень ```L(М') > L(M)```.

Проверку на соблюдение иерархии мьютекс выполняет сам: если во время операции lock мьютекс обнаруживает, что текущий уровень потока-претендента ниже, чем уровень самого мьютекса, то мьютекс аварийно прерывает блокировку.

Для простоты реализации потребуем, чтобы поток мог освобождать только тот мьютекс, который он захватил последним, т.е. последовательности операций вида ```M1.lock() -> M2.lock() -> M1.unlock() -> M2.unlock()``` не допускаются.

ВНИМАНИЕ: иерархический мьютекс не умеет обнаруживать дэдлоки, он умеет обнаруживать случаи нарушения установленной ```lock hierarchy``` (с помощью которой в свою очередь предотвращают дэдлоки).

---—-

Подсказки:

В реализации потребуется для каждого потока хранить его текущий уровень в иерархии (уровень последнего захваченного и удерживаемого на данный момент мьютекса), для этой цели идеально подходит TLS (```thread local storage```): ```thread_local``` в C++11 или расширения конкретного компилятора: ```__thread``` в gcc/clang, ```__declspec(thread)``` в msvc.

В операции ```M.unlock()``` потоку потребуется выполнять откат к предыдущему значению уровня в иерархии, на котором этот поток был до вызова ```M.lock()```. Этот уровень удобно запоминать прямо в мьютексе ```М``` во время ```M.lock()```.
