Сoncurrent heap [concurrent_heap]

Напишите concurrent heap - реализацию приоритетной очереди на основе двоичной кучи (пирамиды), которая бы поддерживала конкурентную работу нескольких вставок (insert) и/или нескольких извлечений (extract-min)

Интерфейс:

insert(key) - вставить в пирамиду ключ key
extract-min() - извлечь из пирамиды минимальный ключ

Пирамиду нужно хранить с помощью линейной развертки дерева в массив, где корень имеет индекс 1, а навигация устроена так:

parent(i) = i / 2
left-child(i) = i * 2
right-child(i) = i * 2 + 1

Используйте мелко-гранулярные (fine-grained) блокировки: на каждый узел пирамиды заведите по спинлоку. 

Для конкурентного выполнения нескольких операций просеивания вверх (sift-up) при вставке используйте технику hand-over-hand locking, она будет гарантировать, что вставка не вмешивается в работу и не видит промежуточного результата других бегущих в это же время вставок.

Аналогично нужно использовать hand-over-hand locking для работы нескольких просеиваний вниз (sift-down) при extract-min.


При hand-over-hand locking используйте unique_lock, не зовите методы ```lock()``` напрямую. При переходе из узла в узел используйте std::move(unique_lock):

std::unique_lock curr_lock(heap[i].spinlock);
std::unique_lock left_child_lock(heap[2 * i].spinlock);
...
curr_lock = std::move(left_child_lock);


Для sift-up и sift-down вам понадобятся две разные иерархии блокировок, чтобы избежать дэдлоков.

Помимо спинлоков на каждый узел, вам понадобится мьютекс/спинлок для работы с глобальным счетчиком числа элементов.

Пирамида будет иметь фиксированную емкость (capacity), которую нужно задать в конструкторе. Если extract-min вызван на пустой пирамиде или insert вызван на пирамиде, в которой нет больше места для новых элементов, то такая операция должна бросать исключение.

При просеивании вниз нужно будет определять, есть ли левый и правый потомок у вершины. Не используйте для этого счетчик числа элементов, т.к. он может уменьшиться, если другой поток извлечет элемент, и прочитанное значение перестанет быть актуальным. Вместо этого для кадого узла заведите флажок EMPTY/VALID и проверяйте его после захвата.


Варианты задачи: 

1) В самом простом варианте вам нужно реализовать пирамиду, которая позволит исполнять одновременно либо несколько вставок, либо только один extract-min, для этого используйте RW-mutex - boost/shared_mutex (или самостоятельно реализованных readers/writer mutex): вставки будут reader-ами, а извлечения - writer-ами.

Т.е. если потоки T1 и T2 вызывают heap.insert(x) и heap.insert(y), а поток T3 вызывает heap.extract_min(), то:
- запускаются две вставки потоков T1 и T2, а T3 блокируется, пока эти вставки не завершатся
- либо сначала запускается T3, который извлекает элемент, а вставки блокируются до завершения операции T3

2) В варианте посложнее нужно реализовать пирамиду, которая позволяла бы работать нескольким вставкам либо нескольким extract-min

3) Самый сложный вариант: реализовать конкурентную работу нескольких вставок и нескольких извлечений, для этого вместе с hand-over-hand locking для извлечений нужно будет применять optimistic locking для вставок. Подробности - в статье:

[1996] G.Hunt, M.Michael, S. Parthasarathy, M.Scott "An efficient algorithm for concurrent priority queue heaps"
 


Реализуйте оптимизацию bit-interleaving для вставок: 

В традиционной реализации пирамиды нижний уровень может быть неполным и заполняется при вставках новых элементов слева направо. Недостаток такого порядка в случае конкурентно работающих вставок - две последовательные вставки при просеивании ключа вверх часто проходят по общим вершинам, в итоге они соревнуются за одни и те же мьютексы/спинлоки и этим замедляют друг друга.

Оказывается, что можно заполнять при вставках нижний уровень пирамиды не слева направо, а таким образом, чтобы две соседние вставки при просеивании вверх могли встретиться только в корне!

При вставках и удалениях в пирамиду нужно поддерживать счетчик числа узлов, который при вставке увеличивается на 1, а при удалении - уменьшается на 1.

Для оптимизации вставок понадобится хитрый счетчик: его начальное значение равно 1, после k-1 инкремента его значение - не k, а rev(k), где rev(x) = разворот всех младших битов числа x до старшего.

Пример: rev(x = 1|01011) = 1|11010

Значение этого счетчика и будет давать индекс очередного листа при вставке.

Как заполняется третий уровень пирамиды:

#вставки			rev		индекс листа
8		1000		1000		8
9		1001		1100		12
10		1010		1010		10
11		1011		1110		14
12		1100		1001		9
13		1101		1101		13
14		1110		1011		11
15		1111		1111		15

Нарисуйте, и сразу все станет понятно =)

---

Напишите простой тест, который демонстрирует, что ваша реализация работает: заведите concurrent_heap<int>, сгенерируйте массив случайных чисел, вставьте их последовательно и затем извлеките.

Напишите stress-test: TODO
